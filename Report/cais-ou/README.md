## 实验报告



### 负责部分

- **系统对加密后文件进行数字签名 【 *数字签名（多种签名工作模式差异）* 】**
- **（可选）文件秒传：服务器上已有的文件，客户端可以不必再重复上传了**
- **提供匿名用户加密后文件和关联的数字签名文件的下载**
- **提供静态文件的散列值下载，供下载文件完成后本地校验文件完整性**



### 具体完成工作

- **系统对加密后文件进行数字签名 【 *数字签名（多种签名工作模式差异）* 】**

  此项工作为协助`BloodyOrangeMan`同学共同完成，引用龙双杰已完成的签名函数在进行文件分享时对加密文件进行签名。

  传入文件后使用用户私钥进行加密，方便接收端使用公钥解密。

  该功能与之后分享链接以及匿名用户下载文件紧密相关。





- **（可选）文件秒传：服务器上已有的文件，客户端可以不必再重复上传了**

- **提供静态文件的散列值下载，供下载文件完成后本地校验文件完整性**

  实现以上功能的思路为：在文件上传时生成一个散列值,将上传文件的散列值与数据库中存在文件的散列值进行比较，若存在相同散列值的函数，则拒绝上传。

  由于`libsodium`在`nodejs`中不存在`crypto_hash_sha256`函数，无法直接调用，于是使用了`nodejs`中存在的`crypto.createHash`生成散列值。

  ```javascript
  exports.sha256 = async (message) => {
    if (!sodium) await onCache;
    const crypto = require('crypto');
    const hash = crypto.createHash('sha256');
    hash.update(message);
    const sha = hash.digest('hex');
    return sha;
  }  // this function is located in backend/utils/cryptoFeatures
  ```

  随后在进行文件上传时查找散列值是否相同，若不相同则正常存入数据库（散列值也将存入数据库方便前端进行显示）。





- **提供匿名用户加密后文件和关联的数字签名文件的下载**

  该功能的实现依赖于`BloodyOrangeMan`同学已封装的加密函数实现。

  实现匿名用户分享文件大致为以下流程：

  1. 用户点击分享按钮，将已使用个人创建的对称密钥加密后的文件解密，随后得到明文文件。

  2. 将明文文件使用随机生成的提取码进行加密，并将散列值合并进入加密后的文件中。

  3. 对加密后文件以及散列值进行数字签名。

  4. 将签名后的文件放入新的`share.files`数据库中，并依据文件`id`、有效使用次数以及文件过期时间生成一串`url`。

  5. 匿名用户点击生成的`url`即可在本地下载签名后的自定义后缀文件，随后使用分享用户的公钥对签名进行验证并得到提取码加密后的文件以及散列值。

  6. 最后匿名用户在本地使用提取码对加密文件进行解密，即可得到原文件。

     

  该套流程中同时加入了文件有效次数判断以及过期时间判断。

  - 有效次数判断：

    每下载一次文件，将数据库中文件有效次数`count`的值减一。

    当检测到文件有效次数为0时，则直接删除该文件。

  - 过期时间判断：

    用户可在前端自定义过期日期，以天数为单位。

    当有效期超过时，则在下载时返回错误提醒。





### 遇到的问题以及解决方法

- 在实现文件分享的过程中，将数据库中存在的文件存入新的数据库时，因为偷懒直接将旧的数据库中的文件信息照搬进新的数据库中。这就导致了同一个文件分享多次时，在新的数据库中存在多个相同`fileID`的文件。这个`BUG`也导致之后下载时，按照`fileID`进行查询时查询出错，进而导致本地解密发生错误。

  - 解决方法：将新生成的`fileID`随机生成，并修改`url`的生成规则。若只修改`fileID`不修改`url`生成时的文件`id`仍会导致下载出错。

    

- 进行有效次数验证时，无法修改数据库中类型为`string`的有效次数`count`的值。

  - 解决方法：需要使用`parseInt()`函数将其类型转换为`Int32`，再使用`$inc: { "metadata.info.count": -1 }`对于有效次数进行修改。

    

- 散列值比对过程中（其他地方也经常遇到），发生一次请求多次响应的问题，猜测为异步处理出错。

  - 解决方法：将原先放在上传文件中的散列值比对代码，放在一个新的函数中，并且在调用上传文件的接口时，将新的散列值比对函数放在上传前，防止比对散列值出结果前先执行上传文件的流程。

